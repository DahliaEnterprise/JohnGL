<!doctype html>
<html>
  <head>
    <title>John GL Presents Game Engine</title>
    <script type="text/javascript">
      /* Venmo: Shane-Betz1990 */
      
      //global variables
        //constant
        var html_canvas_element = null;
        var interface_to_opengles_hardware = null;
        
        //non constants.
        var webgl2_context_attributes = {
                                          alpha: false,
                                          desynchronized: true,
                                          antialiasing: false,
                                          depth: true,
                                          failIfMajorPerformanceCaveat: true,
                                          powerPreference: "high-performance",
                                          premultipliedAlpha: false,
                                          preserveDrawingBuffer: true,
                                          stencil: false
                                       };
                                       
        var canvas_element_width = null;
        var canvas_element_height = null;
        
        var major_scene = 1;
        var major_scene_prestage = 1;
        
        var resource_management_xmlhttprequest = null;
        var resource_management_loaded_data = null;
        var resource_management_status = 0;
        
        /* model framework */
        var game_engine_model_datatypes = {
                                            "two-dimensional-textured-vertex": 1
                                            
                                          };
        /* end of model framework */
        
        /* models */
        var model_placeholder_one_by_one_square = {
                                                    "model_datatype": 1,
                                                    "vertex_coordinate_data": null,
                                                    "texture_coordinate_data": null,
                                                    "image_data": null,
                                                    "data_loaded": false,
                                                    
                                                    "vertex_coordinate_filelocation": "./models/one_by_one_square.opengl_xy_coordinates", 
                                                    "texture_coordinate_filelocation": "./texture_coordinates/one_by_one_square.opengl_xy_texture_coordinates",
                                                    "image_filelocation": null
                                                  };
        /* end of models */
        
        /* handleable variable(s) of open gl format models */
          //Start up/welcome image.
          var vertex_buffer_initial_start_image = null;
          var texture_initial_start_image = null;
          var color_data_filelocation_start_image = "./images/start_image.jpg";
        /* end of open gl format of models */
        
        
      //function definitions
      function start_engine(html_dom_id_of_canvas_element)
      {
        
        //canvas is a null element on the HTML dom.
        html_canvas_element = document.getElementById(""+html_dom_id_of_canvas_element);
       
        //open an associated context between the dom canvas element and openGL ES hardware.
        interface_to_opengles_hardware = html_canvas_element.getContext("webgl2", webgl2_context_attributes);
      
        //define canvas diemensions.
          //define state
          canvas_element_width = 500;
          canvas_element_height = 500;
          
          //define DOM element diemensions according to updated canvas element state.
          document.getElementById("canvas_for_opengles").style.width = canvas_element_width;
          document.getElementById("canvas_for_opengles").style.height = canvas_element_height;
          
          //set the diemensions within the opengl engine and the DOM.
          interface_to_opengles_hardware.viewportWidth = canvas_element_width;
          interface_to_opengles_hardware.viewportHeight = canvas_element_height;
          
          //manually define viewport dimensions within the associated context and hardware.
          interface_to_opengles_hardware.viewport(0, 0, canvas_element_width, canvas_element_height);
        
        //game engine started, proceed to cycle engine(loop).
        cycle_engine();
      }
      
      function cycle_engine()
      {
        /* determination of scene */
        if(major_scene == 1)
        {
          //initalize major scene
          if(major_scene_prestage == 1)
          {
            /* major scene prestage one
               is to load the one by one square
               vertex data.
            */
            if(resource_management_status == 0)
            {
              //update resource management status before calling an asynchronous process
              resource_management_status = 1;
              
              //call asynchronous process that will return vertex coordinate data when the network has streamed(loaded) the data.
              resource_management_loaded_data = null;
              resource_management_xmlhttprequest = new XMLHttpRequest();
              resource_management_xmlhttprequest.addEventListener("load", resource_management_loaded);
              /* place holder for alternative events
              resource_management_xmlhttprequest.addEventListener("error", resource_management_loaded);
              resource_management_xmlhttprequest.addEventListener("progress", resource_management_loaded);
              */
              resource_management_xmlhttprequest.open("GET", ""+model_placeholder_one_by_one_square.vertex_coordinate_filelocation);
              resource_management_xmlhttprequest.send();
            }else if(resource_management_status == 2)
            {
              //convert binary data (response, not responseText) to a Float32Array.
                //split data for iteration
                let resource_management_loaded_data_as_array = resource_management_loaded_data.split(",");
                
                //allocate vertex data coordinate variable for one by one square
                model_placeholder_one_by_one_square.vertex_coordinate_data = null;
                model_placeholder_one_by_one_square.vertex_coordinate_data = new Float32Array(resource_management_loaded_data_as_array.length);
              
                //fill array
                let index_of_array = 0;
                while(index_of_array < resource_management_loaded_data_as_array.length)
                {
                  let abstracted_position = parseFloat(resource_management_loaded_data_as_array[index_of_array]);
                  model_placeholder_one_by_one_square.vertex_coordinate_data[index_of_array] = abstracted_position;
                
                  //next index
                  index_of_array = index_of_array + 1;
                }
                
              //move on to major scene prestage two.
              major_scene_prestage = 2;
              
              //reset resource management parameters
              resource_management_status = 0;
              resource_management_loaded_data = null;
              resource_management_xmlhttprequest = null;
            }
          
          }else if(major_scene_prestage == 2)
          {
            /* major scene prestage two
               is to load the one by one square
               texture coordinate data.
            */
            if(resource_management_status == 0)
            {
              //update resource management status before calling an asynchronous process
              resource_management_status = 1;
              
              //call asynchronous process that will return vertex coordinate data when the network has streamed(loaded) the data.
              resource_management_loaded_data = null;
              resource_management_xmlhttprequest = new XMLHttpRequest();
              resource_management_xmlhttprequest.addEventListener("load", resource_management_loaded);
              /* place holder for alternative events
              resource_management_xmlhttprequest.addEventListener("error", resource_management_loaded);
              resource_management_xmlhttprequest.addEventListener("progress", resource_management_loaded);
              */
              resource_management_xmlhttprequest.open("GET", ""+model_placeholder_one_by_one_square.texture_coordinate_data);
              resource_management_xmlhttprequest.send();
            }else if(resource_management_status == 2)
            {
              //convert binary data (response, not responseText) to a Float32Array.
                //split data for iteration
                let resource_management_loaded_data_as_array = resource_management_loaded_data.split(",");
                
                //allocate texture data coordinate variable for one by one square
                model_placeholder_one_by_one_square.texture_coordinate_data = null;
                model_placeholder_one_by_one_square.texture_coordinate_data = new Float32Array(resource_management_loaded_data_as_array.length);
              
                //fill array
                let index_of_array = 0;
                while(index_of_array < resource_management_loaded_data_as_array.length)
                {
                  let abstracted_position = parseFloat(resource_management_loaded_data_as_array[index_of_array]);
                  model_placeholder_one_by_one_square.texture_coordinate_data[index_of_array] = abstracted_position;
                
                  //next index
                  index_of_array = index_of_array + 1;
                }
                
              //move on to major scene prestage three.
              major_scene_prestage = 3;
              
              //reset resource management parameters
              resource_management_status = 0;
              resource_management_loaded_data = null;
              resource_management_xmlhttprequest = null;
            }
          }else if(major_scene_prestage == 3)
          {
            /* 
               major scene prestage three
               is to load the image(red,green,blue) data.
            */
            //download the image file to be used for the texture.
            if(resource_management_status == 0)
            {
              //update resource management status before calling an asynchronous process
              resource_management_status = 1;
              
              //call asynchronous process that will return vertex coordinate data when the network has streamed(loaded) the data.
              resource_management_loaded_data = null;
              resource_management_xmlhttprequest = new XMLHttpRequest();
              resource_management_xmlhttprequest.addEventListener("load", resource_management_loaded);
              /* place holder for alternative events
              resource_management_xmlhttprequest.addEventListener("error", resource_management_loaded);
              resource_management_xmlhttprequest.addEventListener("progress", resource_management_loaded);
              */
              resource_management_xmlhttprequest.open("GET", ""+color_data_filelocation_start_image);
              resource_management_xmlhttprequest.responseType = "arraybuffer";
              resource_management_xmlhttprequest.send();
            }else if(resource_management_status == 2)
            {
              let bytes = new Uint8Array(resource_management_loaded_data);
              let image_to_upload = new Image();
              image_to_upload.src = "data:image/jpeg;base64,"+btoa(bytes);
              
              //temp
              resource_management_status = 3;
            }else if(resource_management_status == 3)
            {
              
            }
          }else if(major_scene_prestage == 0)
          {
            //execute logic of major scene.
            
          }
        }
        /* end of determination of scene */
        
        
        /* drawing procedures */
        
        
        /* end of drawing proceedures */
        
        
        //commit to the loop paradigm (define a number higher than one ms to allow for gpu cpu cool down)
        setTimeout(cycle_engine, 5);
      }
      
      /* resource management single threaded asynchronous control line */
      function resource_management_loaded(event_data)
      {
        resource_management_loaded_data = event_data.target.response;
       
        resource_management_status = 2;
      }
      /* end of resource management single threaded asynchronous control line */
    </script>
  </head>
  <body onLoad="start_engine('canvas_for_opengles');">
    <canvas id="canvas_for_opengles" width="500" height="500"></canvas>
  </body>
</html>

