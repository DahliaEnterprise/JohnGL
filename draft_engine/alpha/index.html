<!doctype html>
<html>
  <head>
    <title>John GL Presents Game Engine</title>
    <script type="text/javascript">
      /* Venmo: Shane-Betz1990 */
      
      //global variables
        //constant
        var html_canvas_element = null;
        var interface_to_opengles_hardware = null;
        
        //non constants.
        var webgl2_context_attributes = {
                                          alpha: false,
                                          desynchronized: true,
                                          antialiasing: false,
                                          depth: true,
                                          failIfMajorPerformanceCaveat: true,
                                          powerPreference: "high-performance",
                                          premultipliedAlpha: false,
                                          preserveDrawingBuffer: true,
                                          stencil: false
                                       };
                                       
        var canvas_element_width = null;
        var canvas_element_height = null;
        
        var major_scene = 1;
        var major_scene_prestage = 1;
        
        var resource_management_xmlhttprequest = null;
        var resource_management_loaded_data = null;
        var resource_management_status = 0;
        
        /* model framework */
        var game_engine_model_datatypes = {
                                            "two-dimensional-textured-vertex": 1
                                            
                                          };
        /* end of model framework */
        
        /* models */
        var model_placeholder_one_by_one_square = {
                                                    "model_datatype": 1,
                                                    "vertex_coordinate_data": null,
                                                    "texture_coordinate_data": null,
                                                    "image_data": null,
                                                    "data_loaded": false,
                                                    
                                                    "vertex_coordinate_filelocation": "./models/one_by_one_square.opengl_xy_coordinates", 
                                                    "texture_coordinate_filelocation": "./texture_coordinates/one_by_one_square.opengl_xy_texture_coordinates",
                                                    "image_filelocation": null
                                                  };
        /* end of models */
        
        /* handleable variable(s) of open gl format models */
          //Start up/welcome image.
          var vertex_buffer_initial_start_image = null;
          var texture_initial_start_image = null;
          var shader_program_start_image = null;
          var color_data_filelocation_start_image = "./images/start_image.jpg";
           
        /* end of open gl format of models */
        
        /* reuseable handleable variable(s) for the drawing process */
        var drawing_process_uniform_sampler_index_zero = null;
        /* end reuseable handleable variable(s) for the drawing process */
        
      //function definitions
      function start_engine(html_dom_id_of_canvas_element)
      {
        
        //canvas is a null element on the HTML dom.
        html_canvas_element = document.getElementById(""+html_dom_id_of_canvas_element);
       
        //open an associated context between the dom canvas element and openGL ES hardware.
        interface_to_opengles_hardware = html_canvas_element.getContext("webgl2", webgl2_context_attributes);
      
        //define canvas diemensions.
          //define state
          canvas_element_width = 500;
          canvas_element_height = 500;
          
          //define DOM element diemensions according to updated canvas element state.
          document.getElementById("canvas_for_opengles").style.width = canvas_element_width;
          document.getElementById("canvas_for_opengles").style.height = canvas_element_height;
          
          //set the diemensions within the opengl engine and the DOM.
          interface_to_opengles_hardware.viewportWidth = canvas_element_width;
          interface_to_opengles_hardware.viewportHeight = canvas_element_height;
          
          //manually define viewport dimensions within the associated context and hardware.
          interface_to_opengles_hardware.viewport(0, 0, canvas_element_width, canvas_element_height);
        
         /* temporary shader program data */
            var vertex_shader_source = "";
                vertex_shader_source = vertex_shader_source + "attribute vec4 a_Position; \n";
                vertex_shader_source = vertex_shader_source + "attribute vec2 a_TexCoord; \n";
                vertex_shader_source = vertex_shader_source + "varying highp vec2 v_TexCoord; \n";
                vertex_shader_source = vertex_shader_source + "void main(void) { \n";
                vertex_shader_source = vertex_shader_source + "  gl_Position = a_Position; \n"; 
                vertex_shader_source = vertex_shader_source + "  v_TexCoord = a_TexCoord; \n"; 
                vertex_shader_source = vertex_shader_source + "} \n";
            
           
            var fragment_shader_source = "";
                fragment_shader_source = fragment_shader_source + "varying highp vec2 v_TexCoord; \n";
                fragment_shader_source = fragment_shader_source + "uniform sampler2D u_Sampler; \n";
                fragment_shader_source = fragment_shader_source + "void main(void){ \n";
                fragment_shader_source = fragment_shader_source + "  gl_FragColor = texture2D(u_Sampler, v_TexCoord); \n";
                fragment_shader_source = fragment_shader_source + "} \n";
            
            
            var texture_vertex_shader = interface_to_opengles_hardware.createShader(interface_to_opengles_hardware.VERTEX_SHADER);
                interface_to_opengles_hardware.shaderSource(texture_vertex_shader, vertex_shader_source);
                interface_to_opengles_hardware.compileShader(texture_vertex_shader);
           
            var texture_fragment_shader = interface_to_opengles_hardware.createShader(interface_to_opengles_hardware.FRAGMENT_SHADER);
                interface_to_opengles_hardware.shaderSource(texture_fragment_shader, fragment_shader_source);
                interface_to_opengles_hardware.compileShader(texture_fragment_shader);
            
            shader_program_start_image = interface_to_opengles_hardware.createProgram();
                interface_to_opengles_hardware.attachShader(shader_program_start_image, texture_vertex_shader);
                interface_to_opengles_hardware.attachShader(shader_program_start_image, texture_fragment_shader);
                interface_to_opengles_hardware.linkProgram(shader_program_start_image);
                if(!interface_to_opengles_hardware.getProgramParameter(shader_program_start_image, interface_to_opengles_hardware.LINK_STATUS))
                {
                  alert("shader link failed");
                }
            /* end temporary shader program data */
            
        
        //game engine started, proceed to cycle engine(loop).
        cycle_engine();
      }
      
      function cycle_engine()
      {
        /* determination of scene */
        if(major_scene == 1)
        {
          //initalize major scene
          if(major_scene_prestage == 1)
          {
            /* major scene prestage one
               is to load the one by one square
               vertex data.
            */
            if(resource_management_status == 0)
            {
              //update resource management status before calling an asynchronous process
              resource_management_status = 1;
              
              //call asynchronous process that will return vertex coordinate data when the network has streamed(loaded) the data.
              resource_management_loaded_data = null;
              resource_management_xmlhttprequest = new XMLHttpRequest();
              resource_management_xmlhttprequest.addEventListener("load", resource_management_loaded);
              /* place holder for alternative events
              resource_management_xmlhttprequest.addEventListener("error", resource_management_loaded);
              resource_management_xmlhttprequest.addEventListener("progress", resource_management_loaded);
              */
              resource_management_xmlhttprequest.open("GET", ""+model_placeholder_one_by_one_square.vertex_coordinate_filelocation);
              resource_management_xmlhttprequest.send();
            }else if(resource_management_status == 2)
            {
              //convert binary data (response, not responseText) to a Float32Array.
                //split data for iteration
                let resource_management_loaded_data_as_array = resource_management_loaded_data.split(",");
                
                //allocate vertex data coordinate variable for one by one square
                model_placeholder_one_by_one_square.vertex_coordinate_data = null;
                model_placeholder_one_by_one_square.vertex_coordinate_data = new Float32Array(resource_management_loaded_data_as_array.length);
              
                //fill array
                let index_of_array = 0;
                while(index_of_array < resource_management_loaded_data_as_array.length)
                {
                  let abstracted_position = parseFloat(resource_management_loaded_data_as_array[index_of_array]);
                  model_placeholder_one_by_one_square.vertex_coordinate_data[index_of_array] = abstracted_position;
                
                  //next index
                  index_of_array = index_of_array + 1;
                }
                
              //move on to major scene prestage two.
              major_scene_prestage = 2;
              
              //reset resource management parameters
              resource_management_status = 0;
              resource_management_loaded_data = null;
              resource_management_xmlhttprequest = null;
            }
          
          }else if(major_scene_prestage == 2)
          {
            /* major scene prestage two
               is to load the one by one square
               texture coordinate data.
            */
            if(resource_management_status == 0)
            {
              //update resource management status before calling an asynchronous process
              resource_management_status = 1;
              
              //call asynchronous process that will return vertex coordinate data when the network has streamed(loaded) the data.
              resource_management_loaded_data = null;
              resource_management_xmlhttprequest = new XMLHttpRequest();
              resource_management_xmlhttprequest.addEventListener("load", resource_management_loaded);
              /* place holder for alternative events
              resource_management_xmlhttprequest.addEventListener("error", resource_management_loaded);
              resource_management_xmlhttprequest.addEventListener("progress", resource_management_loaded);
              */
              resource_management_xmlhttprequest.open("GET", ""+model_placeholder_one_by_one_square.texture_coordinate_data);
              resource_management_xmlhttprequest.send();
            }else if(resource_management_status == 2)
            {
              //convert binary data (response, not responseText) to a Float32Array.
                //split data for iteration
                let resource_management_loaded_data_as_array = resource_management_loaded_data.split(",");
                
                //allocate texture data coordinate variable for one by one square
                model_placeholder_one_by_one_square.texture_coordinate_data = null;
                model_placeholder_one_by_one_square.texture_coordinate_data = new Float32Array(resource_management_loaded_data_as_array.length);
              
                //fill array
                let index_of_array = 0;
                while(index_of_array < resource_management_loaded_data_as_array.length)
                {
                  let abstracted_position = parseFloat(resource_management_loaded_data_as_array[index_of_array]);
                  model_placeholder_one_by_one_square.texture_coordinate_data[index_of_array] = abstracted_position;
                
                  //next index
                  index_of_array = index_of_array + 1;
                }
                
              //move on to major scene prestage three.
              major_scene_prestage = 3;
              
              //reset resource management parameters
              resource_management_status = 0;
              resource_management_loaded_data = null;
              resource_management_xmlhttprequest = null;
            }
          }else if(major_scene_prestage == 3)
          {
            /* 
               major scene prestage three
               is to load the image(red,green,blue) data.
            */
            //download the image file to be used for the texture.
            if(resource_management_status == 0)
            {
              //update resource management status before calling an asynchronous process
              resource_management_status = 1;
              
              //call asynchronous process that will return red,green,blue data when the network has streamed(loaded) the data.
              resource_management_loaded_data = null;
              resource_management_xmlhttprequest = new XMLHttpRequest();
              resource_management_xmlhttprequest.addEventListener("load", resource_management_loaded);
              /* place holder for alternative events
              resource_management_xmlhttprequest.addEventListener("error", resource_management_loaded);
              resource_management_xmlhttprequest.addEventListener("progress", resource_management_loaded);
              */
              resource_management_xmlhttprequest.open("GET", ""+color_data_filelocation_start_image);
              resource_management_xmlhttprequest.responseType = "arraybuffer";
              resource_management_xmlhttprequest.send();
            }else if(resource_management_status == 2)
            {
              //move image data to a img DOM element.
              let bytes = new Uint8Array(resource_management_loaded_data);
              let image_to_upload = new Image();
              image_to_upload.src = "data:image/jpeg;base64,"+btoa(bytes);
              
              /*temporary drawing proceedure area*/
              //commit to uploading image data to gpu to be used as a reference able variable.
              texture_initial_start_image = interface_to_opengles_hardware.createTexture();
              
              interface_to_opengles_hardware.pixelStorei(interface_to_opengles_hardware.UNPACK_FLIP_Y_WEBGL, 1);
               
              //flag gpu to use TEXTURE0 memory area within the gpu.
              interface_to_opengles_hardware.bindTexture(interface_to_opengles_hardware.TEXTURE_2D, texture_initial_start_image);
              
              //allocate uniform sampler of index zero of the gpu.
              drawing_process_uniform_sampler_index_zero = interface_to_opengles_hardware.getUniformLocation(shader_program_start_image, "uniform_sampler");
              
              //declare which uniform sampler should be used by index(zero). this also creates an associated variable within the context between the developer' input and the gpu' shader render stage.
              interface_to_opengles_hardware.uniform1f(shader_program_start_image, 0);
              
              //declare which filtering the gpu should use during memory reads of interpoliated data within regards to the rendering stage of the gpu upon a cpu initiated draw call.
              interface_to_opengles_hardware.texParameteri(interface_to_opengles_hardware.TEXTURE_2D, interface_to_opengles_hardware.TEXTURE_MIN_FILTER, interface_to_opengles_hardware.LINEAR);
              
              //upload image data(red,green,blue) to the gpu to prepare for a draw call. rgb is used for non transparency, float instead of unsigned byte is used for a larger range of numbers in order to declare that a full range of colors(medium or high definition) should be taken account of during the render stage/render process.
              interface_to_opengles_hardware.texImage2D(interface_to_opengles_hardware.TEXTURE_2D, 0, interface_to_opengles_hardware.RGB, interface_to_opengles_hardware.RGB, interface_to_opengles_hardware.FLOAT, image_to_upload);
              
               //activate the render for this vertex.
               interface_to_opengles_hardware.useProgram(shader_program_start_image);
               interface_to_opengles_hardware.drawArrays(interface_to_opengles_hardware.TRIANGLES, 0, 6);
              
              //move on to resource management status three.
              resource_management_status = 3;
              
            }else if(resource_management_status == 3)
            {
              
              
              //reset resource management parameters
              resource_management_status = 0;
              resource_management_loaded_data = null;
              resource_management_xmlhttprequest = null;
            }
          }else if(major_scene_prestage == 0)
          {
            //execute logic of major scene.
            
          }
        }
        /* end of determination of scene */
        
        
        /* drawing procedures */
        
        
        /* end of drawing proceedures */
        
        
        //commit to the loop paradigm (define a number higher than one ms to allow for gpu cpu cool down)
        setTimeout(cycle_engine, 5);
      }
      
      /* resource management single threaded asynchronous control line */
      function resource_management_loaded(event_data)
      {
        resource_management_loaded_data = event_data.target.response;
       
        resource_management_status = 2;
      }
      /* end of resource management single threaded asynchronous control line */
    </script>
  </head>
  <body onLoad="start_engine('canvas_for_opengles');">
    <canvas id="canvas_for_opengles" width="500" height="500"></canvas>
  </body>
</html>

